C51 COMPILER V9.55   T5557                                                                 04/30/2021 14:43:22 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE T5557
OBJECT MODULE PLACED IN .\Objects\T5557.obj
COMPILER INVOKED BY: C:\Program Files\Keil_v5\C51\BIN\C51.EXE Scr\T5557.c BROWSE INCDIR(.\Header) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\T5557.lst) TABS(2) OBJECT(.\Objects\T5557.obj)

line level    source

   1          #include"T5557.h"
   2          #include"EM41xx.h"
   3          
   4          #define  Start_Gap  20        //起始   160 200     30*8=240  200
   5          #define  GapS       15        //间隔   60  150     15*8=120  100
   6          #define  Bit_One    55        //数据1  220 350     55*8=440  220
   7          #define  Bit_Zero   20        //数据   100 100     25*8=200  100
   8          
   9          #define   TS_8RFmin     (60*(FOSC/1000))/12/1000      //96
  10          #define   TS_8RFmax     (150*(FOSC/1000))/12/1000
  11          #define   T05_8RFmin    (10*(FOSC/1000))/12/1000
  12          #define   T05_8RFmax    (60*(FOSC/1000))/12/1000
  13          #define   TS_16RFmin    (160*(FOSC/1000))/12/1000   //192
  14          #define   TS_16RFmax    (250*(FOSC/1000))/12/1000
  15          #define   T05_16RFmin   (30*(FOSC/1000))/12/1000
  16          #define   T05_16RFmax   (100*(FOSC/1000))/12/1000
  17          #define   TS_32RFmin    (360*(FOSC/1000))/12/1000   //384
  18          #define   TS_32RFmax    (450*(FOSC/1000))/12/1000
  19          #define   T05_32RFmin   (80*(FOSC/1000))/12/1000
  20          #define   T05_32RFmax   (200*(FOSC/1000))/12/1000
  21          #define   TS_40RFmin    (450*(FOSC/1000))/12/1000   //480
  22          #define   TS_40RFmax    (600*(FOSC/1000))/12/1000
  23          #define   T05_40RFmin   (100*(FOSC/1000))/12/1000
  24          #define   T05_40RFmax   (220*(FOSC/1000))/12/1000
  25          #define   TS_50RFmin    (550*(FOSC/1000))/12/1000   //600
  26          #define   TS_50RFmax    (700*(FOSC/1000))/12/1000
  27          #define   T05_50RFmin   (150*(FOSC/1000))/12/1000
  28          #define   T05_50RFmax   (300*(FOSC/1000))/12/1000
  29          #define   TS_64RFmin    (700*(FOSC/1000))/12/1000   //768
  30          #define   TS_64RFmax    (950*(FOSC/1000))/12/1000
  31          #define   T05_64RFmin   (180*(FOSC/1000))/12/1000
  32          #define   T05_64RFmax   (350*(FOSC/1000))/12/1000
  33          #define   TS_100RFmin   (1000*(FOSC/1000))/12/1000  //1200
  34          #define   TS_100RFmax   (1350*(FOSC/1000))/12/1000
  35          #define   T05_100RFmin  (250*(FOSC/1000))/12/1000
  36          #define   T05_100RFmax  (600*(FOSC/1000))/12/1000
  37          #define   TS_128RFmin   (1400*(FOSC/1000))/12/1000  //1536us
  38          #define   TS_128RFmax    (1700*(FOSC/1000))/12/1000
  39          #define   T05_128RFmin  (400*(FOSC/1000))/12/1000
  40          #define   T05_128RFmax  (700*(FOSC/1000))/12/1000
  41          
  42          unsigned int TS_min = TS_32RFmin;
  43          unsigned int TS_max = TS_32RFmax;
  44          unsigned int T05_min = T05_32RFmin;
  45          unsigned int T05_max = T05_32RFmax;
  46          
  47          unsigned char idata T57_Buff[28] = 0;
  48          
  49          void DelayNus(unsigned int us)   //@24MHz
  50          {
  51   1          unsigned char i;
  52   1        
  53   1          EA = 0;
  54   1        
C51 COMPILER V9.55   T5557                                                                 04/30/2021 14:43:22 PAGE 2   

  55   1          while(us--)
  56   1          {
  57   2              i = 3;
  58   2              while (--i);
  59   2          }
  60   1          EA = 1;
  61   1      }
  62          
  63          void Delay8Nus(unsigned char us)  //@24MHz
  64          {
  65   1          unsigned char i;
  66   1        
  67   1          EA = 0;
  68   1        
  69   1          do
  70   1          {
  71   2              i = 62;
  72   2              while (--i);
  73   2          }while(--us);
  74   1          
  75   1          EA = 1;
  76   1      }
  77          
  78          void Contrl_PLL(unsigned char nRF)
  79          {
  80   1          switch(nRF)
  81   1          {
  82   2              case 0x08:
  83   2                        TS_min = TS_8RFmin;
  84   2                        TS_max = TS_8RFmax;
  85   2                        T05_min = T05_8RFmin;
  86   2                        T05_max = T05_8RFmax;         
  87   2                  break;
  88   2              case 0x10:
  89   2                        TS_min = TS_16RFmin;
  90   2                        TS_max = TS_16RFmax;
  91   2                        T05_min = T05_16RFmin;
  92   2                        T05_max = T05_16RFmax;              
  93   2                  break;
  94   2              case 0x20:
  95   2                        TS_min = TS_32RFmin;
  96   2                        TS_max = TS_32RFmax;
  97   2                        T05_min = T05_32RFmin;
  98   2                        T05_max = T05_32RFmax;              
  99   2                  break;
 100   2              case 0x28:
 101   2                        TS_min = TS_40RFmin;
 102   2                        TS_max = TS_40RFmax;
 103   2                        T05_min = T05_40RFmin;
 104   2                        T05_max = T05_40RFmax;              
 105   2                  break;
 106   2              case 0x32:
 107   2                        TS_min = TS_50RFmin;
 108   2                        TS_max = TS_50RFmax;
 109   2                        T05_min = T05_50RFmin;
 110   2                        T05_max = T05_50RFmax;              
 111   2                  break;
 112   2              case 0x40:
 113   2                        TS_min = TS_64RFmin;
 114   2                        TS_max = TS_64RFmax;
 115   2                        T05_min = T05_64RFmin;
 116   2                        T05_max = T05_64RFmax;              
C51 COMPILER V9.55   T5557                                                                 04/30/2021 14:43:22 PAGE 3   

 117   2                  break;    
 118   2              case 0x64:
 119   2                        TS_min = TS_100RFmin;
 120   2                        TS_max = TS_100RFmax;
 121   2                        T05_min = T05_100RFmin;
 122   2                        T05_max = T05_100RFmax;             
 123   2                  break;
 124   2              case 0x80:
 125   2                        TS_min = TS_128RFmin;
 126   2                        TS_max = TS_128RFmax;
 127   2                        T05_min = T05_128RFmin;
 128   2                        T05_max = T05_128RFmax;             
 129   2                  break;        
 130   2          }
 131   1      }
 132          
 133          void Contrl_RF(bit state,unsigned int dtime)  //控制载波时长 
 134          {
 135   1          if(state) 
 136   1          {
 137   2              Carrier_On();          //开启载波
 138   2          }
 139   1          else
 140   1          {
 141   2              Carrier_Off();         //关闭载波
 142   2          }
 143   1          Delay8Nus(dtime); 
 144   1      }
 145          
 146          void Write_Bit(bit dat)
 147          {
 148   1          if(dat)
 149   1              Contrl_RF(1,Bit_One);     //1
 150   1          else
 151   1              Contrl_RF(1,Bit_Zero);    //0   
 152   1          Contrl_RF(0,GapS);            //数据间隔
 153   1      }
 154          
 155          void Write_Start(void)
 156          {
 157   1          Carrier_On();                         //开启载波
 158   1          DelayNus(10000);                      //POR 启动延时6MS 
 159   1          Contrl_RF(0,Start_Gap);               //写起始间隙
 160   1      }
 161          
 162          void Write_Opcode(unsigned char Opcode)   //写操作码  1P/0P
 163          {
 164   1          if((Opcode&0x02)==0x02)
 165   1            Write_Bit(1);
 166   1          else
 167   1            Write_Bit(0);
 168   1          if((Opcode&0x01)==0x01)
 169   1            Write_Bit(1);
 170   1          else
 171   1            Write_Bit(0);   
 172   1      }
 173          /**********************************************************************************/
 174          //void T5557Write_Block(unsigned char _page,           //页 0/1
 175          //                      unsigned char _block,          //块地址
 176          //                      unsigned char_codeEnDisble,    //正常写 0/保护写1
 177          //                      unsigned char Passwrod,        //密码数据
 178          //                      unsigned char Bankdata,        //块数据
C51 COMPILER V9.55   T5557                                                                 04/30/2021 14:43:22 PAGE 4   

 179          //                      unsigned char BankLock)        //块锁
 180          /**********************************************************************************/
 181          
 182          void T5557Write_Block(unsigned char _page,          //页 0/1
 183                                unsigned char _block,         //块地址
 184                                unsigned char _codeEnDisble,  //正常写 0/保护写1
 185                                unsigned long  Passwrod,        //密码数据
 186                                unsigned long  Bankdata,        //块数据
 187                                unsigned char  BankLock)      //块锁
 188          {
 189   1          unsigned char i;
 190   1        
 191   1          Write_Start();    //写起始
 192   1          if(_page == 1)  Write_Opcode(0x03);//操作码11 对1页  操作码
 193   1          else
 194   1          {
 195   2              Write_Opcode(0x02);             //10 对0页  操作码
 196   2          }
 197   1          if(_codeEnDisble)                   //保护写
 198   1          {
 199   2              for(i = 0;i < 32;i ++)          //写密码
 200   2              {
 201   3                  if(Passwrod & 0x80000000) Write_Bit(1);
 202   3                  else
 203   3                      Write_Bit(0);   
 204   3                  Passwrod = Passwrod << 1;                 
 205   3              }         
 206   2          }
 207   1          if(BankLock == 1) Write_Bit(1); //块锁信号 0：不锁  
 208   1          else
 209   1          {
 210   2              Write_Bit(0); 
 211   2          } 
 212   1          for(i = 0;i < 32;i ++)
 213   1          {
 214   2              if(Bankdata & 0x80000000) Write_Bit(1);
 215   2              else
 216   2                 Write_Bit(0);
 217   2              Bankdata = Bankdata << 1;                   
 218   2          } 
 219   1          for(i = 0;i < 3;i ++)       //块地址 0000 0xxx
 220   1          {   
 221   2              if(_block & 0x04) Write_Bit(1);
 222   2              else
 223   2                  Write_Bit(0);
 224   2              _block = _block << 1;
 225   2          }   
 226   1          Carrier_On();               //给卡一个编程的时间
 227   1          DelayNus(10000);
 228   1          Carrier_Off();
 229   1      }
 230          
 231          void Write_Aor(unsigned long W_data)  //AOR唤醒
 232          {
 233   1          unsigned char i;
 234   1          
 235   1          Write_Start();                    //写起始  
 236   1          Write_Opcode(0x02);               //操作码10
 237   1        
 238   1          for(i = 0;i < 32;i ++)            //写密码
 239   1          {
 240   2              if(W_data & 0x80000000)  Write_Bit(1);  
C51 COMPILER V9.55   T5557                                                                 04/30/2021 14:43:22 PAGE 5   

 241   2              else
 242   2                  Write_Bit(0);       
 243   2              W_data = W_data << 1;    
 244   2          }
 245   1          Carrier_On();                     //给卡一个编程的时间    
 246   1      }
 247          
 248          /**********************************************************************************/
 249          //读卡同步头   循环检测200次
 250          //返回值 0失败 1成功
 251          //nRF ：RF/N
 252          /**********************************************************************************/
 253          bit Findhead(unsigned char nRF) 
 254          { 
 255   1          unsigned char n = 50;
 256   1          unsigned int Ts;
 257   1          unsigned int ErrTimes = 0;
 258   1        
 259   1          while(n--)
 260   1          {
 261   2              ErrTimes = 0;
 262   2              TR0 = 0;TH0 = 0;TL0 = 0;      //              +---+
 263   2              while(!INPORT)                //找上升沿  ----+   +------
 264   2              {
 265   3                  ErrTimes ++;
 266   3                  DelayNus(1);
 267   3                  if(ErrTimes == 2500) break;
 268   3              }
 269   2              if(ErrTimes == 2500)  continue;
 270   2              ErrTimes = 0;
 271   2              TR0 = 1; 
 272   2              while(INPORT)                //找下降沿       
 273   2              {
 274   3                  ErrTimes ++;
 275   3                  DelayNus(1);
 276   3                  if(ErrTimes == 2500) break;         
 277   3              }
 278   2              if(ErrTimes == 2500)  continue;
 279   2              ErrTimes = 0;
 280   2              TR0 = 0;
 281   2              Ts = TH0 *256 + TL0;
 282   2              TH0 = 0;TL0 = 0;TR0 = 1;    
 283   2              if(!((TS_min < Ts)&&(Ts < TS_max))) continue;  //检测同步信号1.5P     
 284   2              while(!INPORT)                //等待上升沿
 285   2              {
 286   3                  ErrTimes ++;
 287   3                  DelayNus(1);
 288   3                  if(ErrTimes == 2500) break;               
 289   3              }
 290   2              if(ErrTimes == 2500)  continue;
 291   2              
 292   2              TR0 = 0;
 293   2              Ts = TH0 *256 + TL0;
 294   2              if(Ts > T05_max) continue;      //0.5p,找到同步头
 295   2            
 296   2              Delay8Nus((nRF / 4) + nRF);     //跳过一个数据周期时间        
 297   2              return 1; 
 298   2          }   
 299   1          return 0; 
 300   1      }
 301          
 302          unsigned char T5557ReadPage(unsigned char page,unsigned char nRF)
C51 COMPILER V9.55   T5557                                                                 04/30/2021 14:43:22 PAGE 6   

 303          {
 304   1          bit Demod_Bit;
 305   1          unsigned char i,j,k;
 306   1          unsigned char readCount = 0;
 307   1          unsigned int ErrTimes = 0;
 308   1        
 309   1          Contrl_PLL(nRF);      //设置解码速率
 310   1          Write_Start();        //写起始  
 311   1          if(page == 1) 
 312   1          {
 313   2              Write_Opcode(0x03);   //操作码11
 314   2              readCount = 2;
 315   2          }
 316   1          else
 317   1          {
 318   2              Write_Opcode(0x02);   //操作码10
 319   2              readCount = 7;
 320   2          } 
 321   1          Carrier_On();     //打开磁场
 322   1          
 323   1          if(Findhead(nRF))
 324   1          {
 325   2              for(i = 0;i < readCount;i ++)   //多少个块
 326   2              {
 327   3                  for(j = 0;j < 4;j ++)       //4个字节
 328   3                  {
 329   4                      T57_Buff[(i * 4) + j] = 0;
 330   4                      for(k = 0;k < 8;k ++)   //8bit
 331   4                      {
 332   5                          T57_Buff[(i * 4) + j] = T57_Buff[(i * 4) + j] << 1;
 333   5                          Demod_Bit = INPORT;
 334   5                          if(Demod_Bit) T57_Buff[(i * 4) + j] = T57_Buff[(i * 4) + j] | 0x01;
 335   5                        
 336   5                          ErrTimes = 0;
 337   5                          while(INPORT == Demod_Bit)    //等待跳变
 338   5                          {
 339   6                              ErrTimes ++;
 340   6                              DelayNus(1);
 341   6                          }
 342   5                          if(ErrTimes > TS_min)
 343   5                          {
 344   6                              Carrier_Off();
 345   6                              return 0;
 346   6                          }
 347   5                          Delay8Nus((3 * nRF) / 4);
 348   5                      }
 349   4                  }
 350   3              }
 351   2              Carrier_Off();
 352   2              return 1;
 353   2          }
 354   1          Carrier_Off();
 355   1          return 0;
 356   1      }
 357          /**********************************************************************************/
 358          //void T5557Write_Block(uint8_t _page,            //页 0/1
 359          //                      uint8_t _block,           //块地址
 360          //                      uint8_t _codeEnDisble,    //正常写 0/保护写1
 361          //                      uint32_t Passwrod,        //密码数据
 362          //                      uint32_t Bankdata,        //块数据
 363          //                      uint8_t  BankLock)        //块锁
 364          /**********************************************************************************/
C51 COMPILER V9.55   T5557                                                                 04/30/2021 14:43:22 PAGE 7   

 365          unsigned char T5557Read_Block(unsigned char _page,          //页 0/1
 366                                        unsigned char _block,         //块地址
 367                                        unsigned char _codeEnDisble,  //正常写 0/保护写1
 368                                        unsigned long Passwrod,       //密码数据
 369                                        unsigned char nRF)            //速率                    
 370          {
 371   1          bit Demod_Bit;
 372   1          unsigned char i,j;
 373   1          unsigned int ErrTimes = 0;  
 374   1        
 375   1          Contrl_PLL(nRF);      //设置解码速率
 376   1          
 377   1          Write_Start();       //写起始 
 378   1          if(_page == 1) 
 379   1          {
 380   2              Write_Opcode(0x03);  //操作码11   读1页指定块
 381   2          }
 382   1          else
 383   1          {
 384   2              Write_Opcode(0x02);  //操作码10   读0页指定块
 385   2          } 
 386   1          if(_codeEnDisble == 1)
 387   1          {
 388   2              for(i = 0;i < 32;i ++) //写密码
 389   2              {
 390   3                  if(Passwrod & 0x80000000)  Write_Bit(1);
 391   3                  else
 392   3                      Write_Bit(0);
 393   3                  Passwrod = Passwrod << 1;                 
 394   3              }         
 395   2          }
 396   1          Write_Bit(0);   
 397   1          for(i = 0;i < 3;i ++)      //块地址 0000 0xxx
 398   1          {   
 399   2              if(_block & 0x04) Write_Bit(1);
 400   2              else
 401   2                  Write_Bit(0);
 402   2              _block = _block << 1;
 403   2          } 
 404   1          Carrier_On();
 405   1          
 406   1          if(Findhead(nRF))
 407   1          {
 408   2              for(i = 0;i < 4;i ++)                     //读取4字节数据 
 409   2              {
 410   3                  T57_Buff[i] = 0;
 411   3                  for(j = 0;j < 8;j ++)     
 412   3                  {
 413   4                      T57_Buff[i] = T57_Buff[i] << 1;
 414   4                      Demod_Bit = INPORT;
 415   4                      if(Demod_Bit) T57_Buff[i] = T57_Buff[i]|0x01;
 416   4                    
 417   4                      ErrTimes = 0; 
 418   4                      while(INPORT == Demod_Bit)    //等待跳变
 419   4                      {
 420   5                          ErrTimes ++;
 421   5                          DelayNus(1);
 422   5                      }
 423   4                      if(ErrTimes > TS_min)
 424   4                      {
 425   5                          Carrier_Off();
 426   5                          return 0;
C51 COMPILER V9.55   T5557                                                                 04/30/2021 14:43:22 PAGE 8   

 427   5                      }                 
 428   4                      Delay8Nus((3 * nRF) / 4);
 429   4                  }
 430   3              } 
 431   2              Carrier_Off();
 432   2              return 1; 
 433   2          }
 434   1          Carrier_Off();
 435   1          return 0; 
 436   1      }
 437          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1368    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8      39
   IDATA SIZE       =     28    ----
   BIT SIZE         =   ----       4
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.55   EM41XX                                                                04/30/2021 14:43:21 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE EM41XX
OBJECT MODULE PLACED IN .\Objects\EM41xx.obj
COMPILER INVOKED BY: C:\Program Files\Keil_v5\C51\BIN\C51.EXE Scr\EM41xx.c BROWSE INCDIR(.\Header) DEBUG OBJECTEXTEND PR
                    -INT(.\Listings\EM41xx.lst) TABS(2) OBJECT(.\Objects\EM41xx.obj)

line level    source

   1          #include"EM41xx.h"
   2          #include"Uart.h"
   3          
   4          bit bitin = 0;                    //上一次的姿态位
   5          unsigned char Buff[11];           //解码缓冲区
   6          unsigned char ID[5];              //ID卡号
   7                                         
   8          unsigned int TIME00 = RF64_Min;   //脉宽最小时间    
   9          unsigned int TIME05 = RF64_Mid;   //半个周期时间上限
  10          unsigned int TIME10 = RF64_Max;   //一个周期时间上限  
  11          
  12          void Delay10us()    //@24.000MHz
  13          {
  14   1        unsigned char i;
  15   1      
  16   1        i = 78;
  17   1        while (--i);
  18   1      }
  19          
  20          void T1Clk_Out(unsigned char Pll)
  21          {
  22   1          unsigned int Pll_temp;
  23   1        
  24   1          Pll_temp = 65536 - (FOSC/2/12/1000/Pll);
  25   1        
  26   1          AUXR &= 0xBF;      //12T模式
  27   1          TMOD &= 0x0F;      //模式0
  28   1          TL1 = Pll_temp;
  29   1          TH1 = Pll_temp >> 8;
  30   1          TR1 = 1;           //启动定时器
  31   1          INTCLKO = 0x02;    //使能时钟输出
  32   1      }
  33          
  34          
  35          /*曼彻斯特码解码后的数据放在 Buff[0~10];
  36                  数据格式：1111 1111 同步头，8个1
  37                  数据格式：1xxx xxxx 同步头，1个1，x表示无意义
  38          Buff[0] =     数据格式：D00D01D02D03 P0xxx 八个版本位或厂商信息的前四位，x表示无意义；P0为行效验位
  39          Buff[1] =     数据格式：D10D11D12D13 P1xxx 八个版本位或厂商信息的后四位，x表示无意义；P1为行效验位
  40          Buff[2] =     数据格式：D20D21D22D23 P2xxx 三十二个数据，x表示无意义；P2为行效验位
  41          Buff[3] =     数据格式：D30D31D32D33 P3xxx 三十二个数据，x表示无意义；P3为行效验位
  42          Buff[4] =     数据格式：D40D41D42D43 P4xxx 三十二个数据，x表示无意义；P4为行效验位
  43          Buff[5] =     数据格式：D50D51D52D53 P5xxx 三十二个数据，x表示无意义；P5为行效验位
  44          Buff[6] =     数据格式：D60D61D62D63 P6xxx 三十二个数据，x表示无意义；P6为行效验位
  45          Buff[7] =     数据格式：D70D71D72D73 P7xxx 三十二个数据，x表示无意义；P7为行效验位
  46          Buff[8] =     数据格式：D80D81D82D83 P8xxx 三十二个数据，x表示无意义；P8为行效验位
  47          Buff[9] =     数据格式：D90D91D92D93 P9xxx 三十二个数据，x表示无意义；P9为行效验位
  48          Buff[10] =    数据格式：PC0PC1PC2PC3 0xxx  四个列效验位，x表示无意义；0为停止位
  49          */
  50          
  51          void RFID_Timer0InIt(void)
  52          {
  53   1          AUXR &= 0x7F;     //定时器0时钟为12T模式
  54   1          TMOD &= 0xF0;     //设置定时器模式 16位不自动重装
C51 COMPILER V9.55   EM41XX                                                                04/30/2021 14:43:21 PAGE 2   

  55   1          TMOD |= 0x01;     //设置定时器模式
  56   1          TR0 = 1;          //定时器0开始计时
  57   1          INPORT = 1; 
  58   1      }
  59          
  60          //========================================================================
  61          // 函数: unsigned char readbit(void)
  62          // 描述: EM卡数据位检测
  63          // 参数: 
  64          // 返回: 1 一个周期  2 半个周期  0失败
  65          // 版本: V1.0, 2017-9-23
  66          //========================================================================
  67          unsigned char readbit(void)
  68          {
  69   1          unsigned int mk = TIME10; //装入超时值
  70   1      
  71   1          TL0 = 0;
  72   1          TH0 = 0;                  //初始化定时计数器
  73   1          TR0 = 1;                  //开始计时
  74   1          while(--mk)               //超时机制，防止死等
  75   1          {
  76   2              if(bitin != INPORT)   //有跳变
  77   2              {
  78   3                  Delay10us();
  79   3                  if(bitin != INPORT)   //有跳变
  80   3                        break;
  81   3              }
  82   2          }
  83   1          TR0 = 0;                  //停止计时
  84   1          if(mk==0)                 //超时退出，直接返回 失败
  85   1                return 0;
  86   1          bitin = INPORT;                 //保存IO口状态
  87   1          mk = TH0 * 256 + TL0;             //计算这个跳变的脉宽
  88   1      
  89   1          if((mk>TIME05)&&(mk<=TIME10))   //一个周期时间
  90   1            return 1;
  91   1          if((mk>=TIME00)&&(mk<=TIME05))  //半周期时间
  92   1            return 2;
  93   1          return 0;                       //错误
  94   1      }
  95          
  96          //========================================================================
  97          // 函数: unsigned char readdata(void)
  98          // 描述: 读一个完整的数据位
  99          // 参数: 
 100          // 返回: 
 101          // 版本: V1.0, 2017-9-23
 102          //========================================================================
 103          unsigned char readdata(void)
 104          {
 105   1          switch(readbit())
 106   1          {
 107   2              case 1:                       //一个周期
 108   2                return !bitin;
 109   2              case 2:                       //半个周期
 110   2                if(readbit()!=2) return 2;  //再读半个周期
 111   2                return !bitin;
 112   2              default:
 113   2                return 2;
 114   2          }
 115   1      }
 116          
C51 COMPILER V9.55   EM41XX                                                                04/30/2021 14:43:21 PAGE 3   

 117          //========================================================================
 118          // 函数: bit CheckDataRFID(void)
 119          // 描述: EM4100接收解码
 120          // 参数: 
 121          // 返回: 
 122          // 版本: V1.0, 2017-9-23
 123          //========================================================================
 124          bit CheckDataRFID(void)
 125          {
 126   1          unsigned char i,j;
 127   1        
 128   1          bitin = INPORT;   //保存IO状态
 129   1        
 130   1          for(i=0;i<9;i++)  
 131   1          {
 132   2              if(readdata()!=1)     //不是连续的9个数据1，直接跳出解码函数。
 133   2                return 0;
 134   2          }
 135   1      
 136   1           /////////////////////////////////读取数据///////////////////////////////
 137   1          for(i=0;i<11;i++)      //11个字节
 138   1          {
 139   2              Buff[i] = 0x00;
 140   2              for(j=0;j<5;j++)     //每个字节保存5bit  数据xxxx 校验x
 141   2              {
 142   3                  Buff[i] <<= 1;
 143   3                  switch(readdata())
 144   3                  {
 145   4                      case 0:   //0
 146   4                        break;
 147   4                      case 1:   //1
 148   4                        Buff[i] |= 0x08;
 149   4                        break;
 150   4                      case 2:   //err
 151   4                        return 0;
 152   4                  }
 153   3              }
 154   2          } 
 155   1          ///////////////////////////////////结束位//////////////////////////////
 156   1          if(Buff[10]&0x08!=0x00)
 157   1            return 0;
 158   1          for(i=0;i<10;i++)                   //行奇校验
 159   1            if((((Buff[i]>>4) ^
 160   1                   (Buff[i]>>3) ^
 161   1                   (Buff[i]>>2) ^
 162   1                   (Buff[i]>>1) ^
 163   1                    Buff[i])&0x08)!=0)
 164   1                return 0;   
 165   1                                              
 166   1          j=0;                                //列奇校验
 167   1          for(i=0;i<11;i++)
 168   1            j=j ^ (Buff[i]&0x80);
 169   1          if(j!=0)
 170   1            return 0;
 171   1          for(i=0;i<11;i++)
 172   1            j=j ^ (Buff[i]&0x40);
 173   1          if(j!=0)
 174   1            return 0;
 175   1          for(i=0;i<11;i++)
 176   1            j=j ^ (Buff[i]&0x20);
 177   1          if(j!=0)
 178   1            return 0;
C51 COMPILER V9.55   EM41XX                                                                04/30/2021 14:43:21 PAGE 4   

 179   1          for(i=0;i<11;i++)
 180   1            j=j ^ (Buff[i]&0x10);
 181   1          if(j!=0)
 182   1            return 0; 
 183   1          return 1;         //成功
 184   1      }
 185          
 186          //========================================================================
 187          // 函数: bit ReadEM41xxCardNo(void)
 188          // 描述: EM41数据 合并卡号
 189          // 参数: 
 190          // 返回: 1成功 0失败
 191          // 版本: V1.0, 2017-9-23
 192          //========================================================================
 193          bit ReadEM41xxCardNo(void)
 194          {
 195   1          if(CheckDataRFID())       //检测到卡数据
 196   1          {
 197   2              ID[0]=(Buff[0] & 0xF0) | (Buff[1]>>4 & 0x0F);
 198   2              ID[1]=(Buff[2] & 0xF0) | (Buff[3]>>4 & 0x0F);
 199   2              ID[2]=(Buff[4] & 0xF0) | (Buff[5]>>4 & 0x0F);
 200   2              ID[3]=(Buff[6] & 0xF0) | (Buff[7]>>4 & 0x0F);
 201   2              ID[4]=(Buff[8] & 0xF0) | (Buff[9]>>4 & 0x0F);
 202   2              return 1;
 203   2          } 
 204   1          return 0;   
 205   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    550    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     22       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

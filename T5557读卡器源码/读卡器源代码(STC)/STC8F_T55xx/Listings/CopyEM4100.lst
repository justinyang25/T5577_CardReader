C51 COMPILER V9.55   COPYEM4100                                                            04/30/2021 14:45:22 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE COPYEM4100
OBJECT MODULE PLACED IN .\Objects\CopyEM4100.obj
COMPILER INVOKED BY: C:\Program Files\Keil_v5\C51\BIN\C51.EXE Scr\CopyEM4100.c BROWSE INCDIR(.\Header) DEBUG OBJECTEXTEN
                    -D PRINT(.\Listings\CopyEM4100.lst) TABS(2) OBJECT(.\Objects\CopyEM4100.obj)

line level    source

   1          #include"CopyEM4100.h"
   2          
   3          unsigned long Write_Buf[2];     //写入的数据
   4          
   5          void CopyEM4100Uid(unsigned char *buf)
   6          {
   7   1          unsigned char x,j;
   8   1          unsigned char _Uid[11];
   9   1          
  10   1          for(x = 0;x < 5;x ++)
  11   1          { 
  12   2              _Uid[x * 2]   = buf[x]&0xf0;  //清低4位
  13   2              _Uid[x * 2+1] = buf[x]<<4;     //得到低四位
  14   2          }
  15   1      
  16   1          for(x = 0;x < 10;x ++)               //行校验数据生成
  17   1          {
  18   2            if((((_Uid[x] >> 4) ^
  19   2                 (_Uid[x] >> 3) ^
  20   2                 (_Uid[x] >> 2) ^
  21   2                 (_Uid[x] >> 1) ^
  22   2                  _Uid[x]) & 0x08) != 0)
  23   2              _Uid[x] = _Uid[x] | 0x08;    //将第5位置1
  24   2          }
  25   1          j = 0;
  26   1          for(x = 0;x < 11;x ++)  j = j ^ (_Uid[x] & 0x80);          //列校验数据生成
  27   1          if(j != 0)  _Uid[10] = _Uid[10] | 0x80; 
  28   1          j = 0;
  29   1          for(x = 0;x < 11;x ++)  j = j ^ (_Uid[x] & 0x40);
  30   1          if(j != 0)  _Uid[10] = _Uid[10] | 0x40;
  31   1          j = 0;
  32   1          for(x = 0;x < 11;x ++)  j = j ^ (_Uid[x] & 0x20);
  33   1          if(j != 0)  _Uid[10] = _Uid[10] | 0x20;
  34   1          j = 0;
  35   1          for(x = 0;x < 11;x ++)  j = j ^ (_Uid[x] & 0x10);
  36   1          if(j !=0 )  _Uid[10] = _Uid[10] | 0x10;     
  37   1          for(x = 0;x < 11;x ++)    Buff[x] = _Uid[x];    //转换好的数据，放入Buff缓冲等待合并数据        
  38   1      }
  39          
  40          void Write_DataManage(void)
  41          { 
  42   1          Write_Buf[1] = 0;                         
  43   1          Write_Buf[0] = 0x000001FF;    // 0000 0000 0000 0000  0000 0001 1111 1111
  44   1          Write_Buf[0] = (Write_Buf[0] << 5) | (Buff[0] >> 3); 
  45   1          Write_Buf[0] = (Write_Buf[0] << 5) | (Buff[1] >> 3);
  46   1          Write_Buf[0] = (Write_Buf[0] << 5) | (Buff[2] >> 3);
  47   1          Write_Buf[0] = (Write_Buf[0] << 5) | (Buff[3] >> 3);
  48   1          Write_Buf[0] = (Write_Buf[0] << 3) | (Buff[4] >> 5);
  49   1          Write_Buf[1] = (Buff[4] >> 3) & 0x03;                   
  50   1          Write_Buf[1] = (Write_Buf[1] << 5) | (Buff[5] >> 3);    
  51   1          Write_Buf[1] = (Write_Buf[1] << 5) | (Buff[6] >> 3);  
  52   1          Write_Buf[1] = (Write_Buf[1] << 5) | (Buff[7] >> 3);  
  53   1          Write_Buf[1] = (Write_Buf[1] << 5) | (Buff[8] >> 3);  
  54   1          Write_Buf[1] = (Write_Buf[1] << 5) | (Buff[9] >> 3);  
C51 COMPILER V9.55   COPYEM4100                                                            04/30/2021 14:45:22 PAGE 2   

  55   1          Write_Buf[1] = (Write_Buf[1] << 5) | (Buff[10] >> 3); 
  56   1      }
  57          
  58          void EM4305CopyEM4100(unsigned char *buf)
  59          {
  60   1          unsigned char x,y;
  61   1          unsigned char idata buff_x[8];  
  62   1          
  63   1          EA = 0;
  64   1          CopyEM4100Uid(buf);
  65   1          Write_DataManage();
  66   1          for(x=0;x<4;x++)  //移位
  67   1          {
  68   2              for(y=0;y<8;y++)
  69   2              {
  70   3                  buff_x[x] = buff_x[x]>>1;
  71   3                  Write_Buf[0] = Write_Buf[0]<<1;
  72   3                  if(CY) buff_x[x] = buff_x[x]|0x80;
  73   3              } 
  74   2          }
  75   1          for(x=4;x<8;x++)  //移位
  76   1          {
  77   2              for(y=0;y<8;y++)
  78   2              {
  79   3                  buff_x[x] = buff_x[x]>>1;
  80   3                  Write_Buf[1] = Write_Buf[1]<<1;
  81   3                  if(CY) buff_x[x] = buff_x[x]|0x80;
  82   3              } 
  83   2          }
  84   1          Write_block(0,0x01,0x80,0x5f,0x04);   //写配置块
  85   1          Delay_8nus(6250);
  86   1          Write_block(buff_x[3],buff_x[2],buff_x[1],buff_x[0],0x05);
  87   1          Delay_8nus(6250);
  88   1          Write_block(buff_x[7],buff_x[6],buff_x[5],buff_x[4],0x06);
  89   1          Delay_8nus(6250);
  90   1          EA = 1;
  91   1      }
  92          
  93          void T5557CopyEM4100(unsigned char *buf)
  94          {
  95   1          EA = 0;
  96   1          CopyEM4100Uid(buf);
  97   1          Write_DataManage();
  98   1          T5557Write_Block(0,0,0,0,E5557_Config,0);//写配置块   
  99   1          Delay_8nus(1250);
 100   1          T5557Write_Block(0,1,0,0,Write_Buf[0],0);//写0页第一块
 101   1          Delay_8nus(1250);
 102   1          T5557Write_Block(0,2,0,0,Write_Buf[1],0);//写0页第二块    
 103   1          EA = 1;     
 104   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1038    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8      16
   IDATA SIZE       =   ----       8
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
